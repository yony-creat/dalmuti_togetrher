<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë‹¬ë¬´í‹° ë©€í‹°í”Œë ˆì´</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
   <style>
        :root { --bg-color: #1a252f; --accent: #f1c40f; --card-bg: #ffffff; }
        body { font-family: 'Malgun Gothic', sans-serif; background-color: var(--bg-color); color: white; margin: 0; padding: 10px; text-align: center; }
        #status-bar { padding: 10px; margin-bottom: 10px; border-radius: 8px; font-size: 14px; background: #c0392b; font-weight: bold; }
        .online { background: #27ae60 !important; }
        .screen { background: rgba(0,0,0,0.7); padding: 20px; border-radius: 15px; max-width: 500px; margin: 10px auto; border: 1px solid #34495e; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .card-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-top: 15px; min-height: 110px; }
        .card { 
            width: 65px; height: 95px; background: var(--card-bg); border-radius: 8px; 
            border: 2px solid #333; cursor: pointer; display: flex; align-items: center; 
            justify-content: center; color: #2c3e50; font-weight: bold; font-size: 28px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3); transition: transform 0.2s;
        }
        .card.selected { transform: translateY(-15px); border: 3px solid #e67e22; background: #fff9e6; }
        .card.disabled { opacity: 0.6; cursor: default; background: #bdc3c7; color: #7f8c8d; }
        #rank-board { background: rgba(255, 255, 255, 0.1); border-radius: 10px; padding: 10px; margin-bottom: 15px; display: flex; flex-wrap: wrap; justify-content: center; gap: 5px; }
        .rank-badge { padding: 5px 10px; border-radius: 15px; font-size: 0.8rem; background: #34495e; border: 1px solid var(--accent); }
        button { padding: 12px; border-radius: 8px; border: none; background: #e67e22; color: white; font-weight: bold; cursor: pointer; margin: 5px; width: 85%; font-size: 16px; }
        .hidden { display: none !important; }
        input { padding: 12px; width: 80%; border-radius: 5px; border: 2px solid #34495e; font-size: 16px; margin-bottom: 10px; text-align: center; }
        .turn-msg { font-size: 1.1rem; color: var(--accent); font-weight: bold; margin: 10px 0; }
        .role-item { margin: 8px 0; padding: 10px; border-radius: 8px; background: rgba(255,255,255,0.1); text-align: left; border-left: 4px solid var(--accent); }
   .badge-dalmuti { background: #f1c40f !important; color: #000; } /* í™©ê¸ˆìƒ‰ */
    .badge-peon { background: #95a5a6 !important; } /* íšŒìƒ‰ */
    .badge-common { background: #34495e !important; } 
   </style>
</head>
<body>
    <div id="status-bar">ì„œë²„ ì—°ê²° ì¤‘...</div>

    <div id="setup" class="screen">
        <h2 style="color:var(--accent)">ğŸ° ë‹¬ë¬´í‹°</h2>
        <input type="text" id="my-name" placeholder="ë‹‰ë„¤ì„ ì…ë ¥" maxlength="8">
        <button onclick="initPeer(true)">ë°© ë§Œë“¤ê¸° (ë°©ì¥)</button>
        <hr style="border:0.5px solid #444; margin:15px 0;">
        <input type="text" id="join-id" placeholder="ë°© ì½”ë“œê°€ ìë™ ì…ë ¥ë©ë‹ˆë‹¤">
        <button onclick="initPeer(false)" style="background:#2980b9;">ë°© ì°¸ì—¬í•˜ê¸°</button>
    </div>

    <div id="lobby" class="screen hidden">
        <h3>ğŸ“¢ ëŒ€ê¸°ì‹¤</h3>
        <button onclick="copyRoomLink()" style="background:#8e44ad; width:auto; padding:8px 15px;">ğŸ”— ì´ˆëŒ€ ë§í¬ ë³µì‚¬</button>
        <div id="player-list-lobby" style="margin: 20px 0;"></div>
        <button id="start-btn" onclick="hostStartRoleDraw()" class="hidden">ì„œì—´ ì •í•˜ê¸° ì‹œì‘</button>
    </div>

    <div id="role-draw" class="screen hidden">
        <h3>ğŸƒ ì„œì—´ ì •í•˜ê¸°</h3>
        <div id="role-turn-msg" class="turn-msg"></div>
        <div id="role-cards" class="card-container"></div>
        <div id="role-results" style="margin-top:15px;"></div>
    </div>

    <div id="tax-phase" class="screen hidden">
        <h3>ğŸ’° ì„¸ê¸ˆ ë° í•˜ì‚¬</h3>
        <p id="tax-instruction"></p>
        <div id="tax-hand" class="card-container"></div>
        <p id="tax-msg" style="color:#ff7675; font-weight:bold; margin:10px 0;"></p>
        <button id="tax-btn" onclick="submitTax()">ì¹´ë“œ ì „ë‹¬</button>
    </div>

    <div id="game-board" class="screen hidden">
        <div id="rank-board"></div>
        <div id="turn-display" class="turn-msg"></div>
        <div id="table-cards" class="card-container" style="min-height:120px; background:rgba(255,255,255,0.05); border-radius:10px; padding:10px;"></div>
        <div id="my-hand" class="card-container"></div>
        <div style="margin-top:15px;">
            <button onclick="playCards()">ì¹´ë“œ ë‚´ê¸°</button>
            <button onclick="passTurn()" style="background:#7f8c8d;">í†µê³¼ (Pass)</button>
        </div>
<div id="round-result-screen" class="screen hidden">
        <h2 style="color:var(--accent)">ğŸ† ë¼ìš´ë“œ ì¢…ë£Œ ğŸ†</h2>
        <div id="final-ranking-list" style="margin: 20px 0;"></div>
        <button onclick="finalizeRoles()" style="background:#2ecc71;">ì´ ì„œì—´ë¡œ ë‹¤ìŒ íŒ ì‹œì‘</button>
        <button onclick="location.reload()" style="background:#e74c3c;">ì™„ì „ ìƒˆë¡œ ì‹œì‘(ë°© í­íŒŒ)</button>
    </div>
    </div>

<script>
    let peer, conn, connections = [];
    let isHost = false, myID = "", myName = "";
    let players = [], currentPlayerIdx = 0, lastPlayed = {rank:14, count:0}, selectedCards = [], passCount = 0;
    let taxStorage = [], roleDrawingIdx = 0, roleDeck = [];
    let finishOrder = [];

    window.onload = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const room = urlParams.get('room');
        if (room) document.getElementById('join-id').value = room;
    };

    function copyRoomLink() {
        const link = `${window.location.origin}${window.location.pathname}?room=${myID}`;
        navigator.clipboard.writeText(link).then(() => alert("ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!"));
    }

    function updateLobby() {
        const list = document.getElementById('player-list-lobby');
        list.innerHTML = players.map(p => `<div>ğŸ‘¤ ${p.name} ${p.id === myID ? '(ë‚˜)' : ''}</div>`).join('');
        if(isHost && players.length >= 2) {
            document.getElementById('start-btn').classList.remove('hidden');
        }
    }
    function initPeer(host) {
        myName = document.getElementById('my-name').value.trim();
        if (!myName) return alert("ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”!");
        isHost = host;
        peer = new Peer();
        peer.on('open', id => {
            myID = id;
            document.getElementById('status-bar').innerText = isHost ? "ë°©ì¥ì´ ë˜ì—ˆìŠµë‹ˆë‹¤" : "ì—°ê²°ë¨";
            document.getElementById('status-bar').classList.add('online');
            if(isHost) {
                players.push({id, name:myName, hand:[], isFinished:false});
                showScreen('lobby'); updateLobby();
            } else {
                conn = peer.connect(document.getElementById('join-id').value.trim());
                setupConn(conn);
            }
        });
        peer.on('connection', setupConn);
    }

    function setupConn(c) {
        if(isHost) connections.push(c);
        c.on('open', () => { if(!isHost) c.send({type:'JOIN', name:myName}); });
        c.on('data', data => handleData(data, c));
    }

    function handleData(data, c) {
        switch(data.type) {
            case 'JOIN':
                if(isHost) {
                    players.push({id:c.peer, name:data.name, hand:[], isFinished:false});
                    updateLobby(); broadcast({type:'LOBBY', players});
                }
                break;
            case 'LOBBY': players = data.players; updateLobby(); showScreen('lobby'); break;
            case 'START_DRAW_PHASE':
                players = data.players; roleDrawingIdx = 0;
                showRoleDrawScreen(players.length); updateRoleTurnMsg();
                break;
            case 'ROLE_PICKED': if(isHost) processRolePick(data.cardIdx, c.peer); break;
            case 'ROLE_OPEN':
                renderOpenedRole(data.cardIdx, data.rank, data.pName);
                roleDrawingIdx = data.nextIdx; updateRoleTurnMsg();
                if(data.isAllDone && isHost) setTimeout(finalizeRoles, 1500);
                break;

            // [ì´ ë¶€ë¶„ì„ ìˆ˜ì •/êµì²´í•˜ì„¸ìš”]
            case 'TAX_START': 
                players = data.players; 
                startTaxPhase(); 
                updateStatusBar(); // í•˜ë‹¨ì— ì„¤ëª…í•  ìƒíƒœë°” ì—…ë°ì´íŠ¸ í•¨ìˆ˜ í˜¸ì¶œ
                break;

            case 'DALMUTI_WAIT':
                taxStorage = data.taxCards;
                const isDalmuti = (players[0].id === myID);
                showScreen('tax-phase');
                if(isDalmuti) {
                    document.getElementById('tax-instruction').innerHTML = "ë†ë…¸ì˜ ì¡°ê³µì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤.<br>ì´ì œ í•˜ì‚¬í•  <b>ì¹´ë“œ 2ì¥</b>ì„ ê³ ë¥´ì„¸ìš”.";
                    document.getElementById('tax-btn').classList.remove('hidden');
                    renderHand('tax-hand', players.find(p => p.id === myID).hand, true);
                } else {
                    document.getElementById('tax-instruction').innerText = "ë‹¬ë¬´í‹°ê°€ í•˜ì‚¬í’ˆì„ ê³ ë¥´ê³  ìˆìŠµë‹ˆë‹¤...";
                    document.getElementById('tax-btn').classList.add('hidden');
                }
                break;

            case 'GAME_START':
                players = data.players; currentPlayerIdx = data.turn; lastPlayed = data.last;
                showScreen('game-board'); updateUI(); updateStatusBar(); break;

                case 'SHOW_RESULT':
                players = data.players;
                showRoundResult(); // ì œê°€ ì´ì „ì— ë“œë¦° ê²°ê³¼ ì°½ ë„ìš°ëŠ” í•¨ìˆ˜ í˜¸ì¶œ
                break;
                
            case 'PLAY_REQ': if(isHost) doPlay(data.rank, data.count, data.pIdx); break;
            case 'PASS_REQ': if(isHost) doPass(); break;
            case 'PEON_TAX': if(isHost) handlePeonTax(data.cards); break;
            case 'DAL_TAX_REQ': if(isHost) handleDalTax(data.cards); break;
        }
    }
    function broadcast(data) { connections.forEach(c => c.send(data)); }

    function hostStartRoleDraw() {
        roleDeck = Array.from({length: 12}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
        roleDrawingIdx = 0;
        const msg = {type:'START_DRAW_PHASE', players: players};
        handleData(msg); broadcast(msg);
    }

    function processRolePick(cardIdx, pickerID) {
        const rank = roleDeck.pop();
        const pIdx = players.findIndex(p => p.id === pickerID);
        players[pIdx].initRank = rank;
        const nextIdx = roleDrawingIdx + 1;
        const isAllDone = nextIdx >= players.length;
        const msg = {type:'ROLE_OPEN', cardIdx, rank, pName: players[pIdx].name, nextIdx, isAllDone};
        handleData(msg); broadcast(msg);
    }

    function renderOpenedRole(idx, rank, name) {
        const card = document.getElementById(`role-card-${idx}`);
        if(card) { card.innerText = rank; card.classList.add('disabled'); }
        document.getElementById('role-results').innerHTML += `<div class="role-item">ğŸ‘¤ ${name}: <b>${rank}</b></div>`;
    }

    function showRoleDrawScreen(count) {
        showScreen('role-draw');
        const container = document.getElementById('role-cards');
        container.innerHTML = ''; document.getElementById('role-results').innerHTML = '';
        for(let i=0; i<count; i++) {
            container.innerHTML += `<div class="card" id="role-card-${i}" onclick="tryPickRole(${i})">?</div>`;
        }
    }

    function tryPickRole(cardIdx) {
        if(players[roleDrawingIdx].id !== myID) return alert("ìê¸° ì°¨ë¡€ê°€ ì•„ë‹™ë‹ˆë‹¤!");
        if(document.getElementById(`role-card-${cardIdx}`).classList.contains('disabled')) return;
        if(isHost) processRolePick(cardIdx, myID);
        else conn.send({type:'ROLE_PICKED', cardIdx});
    }

    function updateRoleTurnMsg() {
        if (roleDrawingIdx >= players.length) return;
        const p = players[roleDrawingIdx];
        document.getElementById('role-turn-msg').innerText = (p.id === myID) ? "ğŸ”´ ë‹¹ì‹ ì˜ ì°¨ë¡€! ì¹´ë“œë¥¼ ë½‘ìœ¼ì„¸ìš”." : `âŒ› ${p.name}ë‹˜ì´ ë½‘ëŠ” ì¤‘...`;
    }

   function finalizeRoles() {
        // ì´ë¯¸ ê²Œì„ì„ í•œ ë²ˆ í•´ì„œ ì„œì—´ì´ ì •í•´ì§„ ìƒíƒœë¼ë©´ ì •ë ¬ì„ ìƒëµí•˜ê³  ë°”ë¡œ ì¹´ë“œ ë¶„ë°°
        // (nextTurnì—ì„œ ì´ë¯¸ players ë°°ì—´ì´ ìˆœìœ„ëŒ€ë¡œ ì •ë ¬ë˜ì—ˆê¸° ë•Œë¬¸)
        if (!players[0].role) {
            players.sort((a,b) => a.initRank - b.initRank);
        }
        
        players.forEach((p,i) => {
            p.isFinished = false; // ìƒíƒœ ì´ˆê¸°í™”
            p.role = i===0?"ğŸ‘‘ ë‹¬ë¬´í‹°":(i===players.length-1?"ğŸ’© ë†ë…¸":`${i+1}ë“± í‰ë¯¼`);
        });
        
        dealCards();
    }
    function dealCards() {
        let deck = []; for(let i=1; i<=12; i++) for(let j=0; j<i; j++) deck.push(i);
        deck.push(13,13); deck.sort(()=>Math.random()-0.5);
        players.forEach(p => { p.hand = []; p.isFinished = false; });
        let i=0; while(deck.length) players[i++ % players.length].hand.push(deck.pop());
        players.forEach(p => p.hand.sort((a,b)=>a-b));
        const msg = {type:'TAX_START', players}; handleData(msg); broadcast(msg);
    }

    function startTaxPhase() {
        showScreen('tax-phase');
        const isPeon = (players[players.length-1].id === myID);
        const me = players.find(p => p.id === myID);
        document.getElementById('tax-btn').classList.toggle('hidden', !isPeon);
        if(isPeon) {
            document.getElementById('tax-instruction').innerHTML = "<b>ë†ë…¸</b>ë‹˜, ê°€ì¥ ì¢‹ì€ ì¹´ë“œ 2ì¥ì„ ë‚´ì„¸ìš”.";
            renderHand('tax-hand', me.hand, true);
        } else { document.getElementById('tax-instruction').innerText = "ë†ë…¸ì˜ ì„¸ê¸ˆì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘..."; }
    }
function submitTax() {
        if(selectedCards.length !== 2) return alert("2ì¥ì„ ê³ ë¥´ì„¸ìš”.");
        
        const isPeon = (players[players.length - 1].id === myID); // ë‚´ê°€ ë†ë…¸ì¸ì§€ í™•ì¸
        const isDalmuti = (players[0].id === myID); // ë‚´ê°€ ë‹¬ë¬´í‹°ì¸ì§€ í™•ì¸

        if(isPeon) { 
            // 1. ë†ë…¸ ê²€ì¦ ë¡œì§
            const pIdx = players.findIndex(p => p.id === myID);
            const best = [...players[pIdx].hand].sort((a,b)=>a-b).slice(0,2);
            const mine = selectedCards.map(s=>s.rank).sort((a,b)=>a-b);
            
            if(mine[0]!==best[0] || mine[1]!==best[1]) {
                return alert(`ë†ë…¸ ë„¤ ì´ë†ˆ! (${best[0]}, ${best[1]}ë²ˆ ì¹´ë“œë¥¼ ë‚´ì•¼ í•¨)`);
            }
            
            // ë†ë…¸ê°€ ë°©ì¥ì´ë©´ ì§ì ‘ ì²˜ë¦¬, ì°¸ì—¬ìë©´ ë°©ì¥ì—ê²Œ ì „ì†¡
            if(isHost) handlePeonTax(selectedCards); 
            else conn.send({type:'PEON_TAX', cards:selectedCards});

        } else if(isDalmuti) {
            // 2. ë‹¬ë¬´í‹° í•˜ì‚¬ ë¡œì§ (ì´ ë¶€ë¶„ì´ ìˆ˜ì •ë˜ì–´ì•¼ í•¨)
            if(isHost) {
                // ë‹¬ë¬´í‹°ê°€ ë°©ì¥ì¸ ê²½ìš° ì§ì ‘ ì‹¤í–‰
                handleDalTax(selectedCards); 
            } else {
                // ë‹¬ë¬´í‹°ê°€ ì°¸ì—¬ìì¸ ê²½ìš° ë°©ì¥ì—ê²Œ í•˜ì‚¬í’ˆ ì •ë³´ë¥¼ ë³´ëƒ„
                conn.send({type:'DAL_TAX_REQ', cards:selectedCards});
            }
        }
    }

  // [ë°©ì¥ ì „ìš©] ë†ë…¸ì˜ ì¡°ê³µì„ ì²˜ë¦¬í•˜ê³  ë‹¬ë¬´í‹°ì—ê²Œ í„´ì„ ë„˜ê¹ë‹ˆë‹¤.
    function handlePeonTax(selectedIndices) {
        const peon = players[players.length - 1];
        taxStorage = [];
        
        // ì¸ë±ìŠ¤ë¥¼ í° ìˆœì„œëŒ€ë¡œ ì •ë ¬í•˜ì—¬ ì›ë³¸ ë°°ì—´ ì œê±° ì‹œ ì¸ë±ìŠ¤ ê¼¬ì„ ë°©ì§€
        selectedIndices.sort((a, b) => b.idx - a.idx).forEach(c => {
            taxStorage.push(peon.hand.splice(c.idx, 1)[0]);
        });

        // ì¤‘ìš”: ë°©ì¥ ë³¸ì¸ í™”ë©´ì„ ì—…ë°ì´íŠ¸í•˜ê³ , ëª¨ë“  ì°¸ì—¬ìì—ê²Œë„ 'ë‹¬ë¬´í‹° ì°¨ë¡€'ì„ì„ ì•Œë¦½ë‹ˆë‹¤.
        const msg = { type: 'DALMUTI_WAIT', taxCards: taxStorage };
        handleData(msg); 
        broadcast(msg); 
    }
// [ë°©ì¥ ì „ìš©] ë‹¬ë¬´í‹°ê°€ í•˜ì‚¬í•œ ì¹´ë“œë¥¼ ì²˜ë¦¬í•˜ê³  ê²Œì„ì„ ì§„ì§œë¡œ ì‹œì‘í•©ë‹ˆë‹¤.
    function handleDalTax(cards) {
        if (!isHost) return; // ë°©ì¥ë§Œ ì‹¤í–‰í•˜ëŠ” ë¡œì§ì…ë‹ˆë‹¤.

        const dal = players[0];
        const peon = players[players.length - 1];

        // 1. ë‹¬ë¬´í‹°ì˜ ì†íŒ¨ì—ì„œ ì„ íƒí•œ ì¹´ë“œ ì œê±° í›„ ë†ë…¸ì—ê²Œ ì „ë‹¬
        // ì¸ë±ìŠ¤ ê¼¬ì„ ë°©ì§€ë¥¼ ìœ„í•´ ë’¤ì—ì„œë¶€í„° ì œê±°í•©ë‹ˆë‹¤.
        cards.sort((a, b) => b.idx - a.idx).forEach(c => {
            peon.hand.push(dal.hand.splice(c.idx, 1)[0]);
        });

        // 2. ë†ë…¸ê°€ ì•„ê¹Œ ë°”ì³¤ë˜ ì¡°ê³µ(taxStorage)ì„ ë‹¬ë¬´í‹°ì˜ ì†íŒ¨ì— ì¶”ê°€
        dal.hand.push(...taxStorage);

        // 3. ëª¨ë“  í”Œë ˆì´ì–´ì˜ ì†íŒ¨ë¥¼ ë‹¤ì‹œ ìˆ«ì ìˆœì„œëŒ€ë¡œ ì •ë ¬
        players.forEach(p => p.hand.sort((a, b) => a - b));

        // 4. ëª¨ë“  ì°¸ì—¬ìì—ê²Œ "ì´ì œ ê²Œì„ ì‹œì‘ì´ë‹¤!"ë¼ê³  ì‹ í˜¸ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.
        const msg = {
            type: 'GAME_START',
            players: players,
            turn: 0, // ë‹¬ë¬´í‹°(ë°©ì¥)ë¶€í„° ì‹œì‘
            last: { rank: 14, count: 0 }
        };

        handleData(msg); // ë°©ì¥ ë³¸ì¸ í™”ë©´ì„ ê²Œì„íŒìœ¼ë¡œ ì „í™˜
        broadcast(msg);  // ì°¸ì—¬ì(ë†ë…¸ ë“±)ì˜ í™”ë©´ì„ ê²Œì„íŒìœ¼ë¡œ ê°•ì œ ì „í™˜
    }
    // [í‘œì‹œ ì „ìš©] ìƒë‹¨ì— ë‹¬ë¬´í‹°ì™€ ë†ë…¸ ì •ë³´ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.
    function updateStatusBar() {
        if (players.length < 2) return;
        const dalmuti = players[0];
        const peon = players[players.length - 1];
        const statusEl = document.getElementById('status-bar');
        
        statusEl.innerHTML = `
            <span style="color:var(--accent)">ğŸ‘‘ ${dalmuti.name}(${dalmuti.hand.length})</span> | 
            <span style="color:#bdc3c7">ğŸ’© ${peon.name}(${peon.hand.length})</span>
        `;
    }

    function updateUI() {
        const me = players.find(p => p.id === myID);
        const isMyTurn = players[currentPlayerIdx].id === myID;
        
        // [ìˆ˜ì •] ë°”ë‹¥ì´ ì²­ì†Œë˜ì—ˆì„ ë•Œ ë¬¸êµ¬ ê°•ì¡°
        let turnMsg = isMyTurn ? "ğŸ”´ ë‚´ ì°¨ë¡€!" : `âŒ› ${players[currentPlayerIdx].name} ì°¨ë¡€`;
        if (isMyTurn && lastPlayed.count === 0) {
            turnMsg = "âœ¨ ë°”ë‹¥ ì²­ì†Œë¨! ì›í•˜ëŠ” ì¹´ë“œë¥¼ ë‚´ì„¸ìš”! âœ¨";
        }
        document.getElementById('turn-display').innerText = turnMsg;

        // ìƒë‹¨ í”Œë ˆì´ì–´ ë¦¬ìŠ¤íŠ¸ ë° ì¹´ë“œ ìˆ˜
        document.getElementById('rank-board').innerHTML = players.map(p => 
            `<span class="rank-badge">${p.name}(${p.hand.length})</span>`
        ).join('');

        // ë‚´ ì†íŒ¨ ê·¸ë¦¬ê¸°
        renderHand('my-hand', me.hand, isMyTurn);

        // [ìˆ˜ì •] í…Œì´ë¸” ì¤‘ì•™ ì¹´ë“œ ì˜ì—­ í‘œì‹œ
        const table = document.getElementById('table-cards'); 
        table.innerHTML = '';
        if(lastPlayed.count > 0) {
            for(let i=0; i<lastPlayed.count; i++) {
                table.innerHTML += `<div class="card">${lastPlayed.rank===13?'J':lastPlayed.rank}</div>`;
            }
        } else {
            // ë°”ë‹¥ì´ ë¹„ì—ˆì„ ë•Œ ì‹œê°ì  ì•ˆë‚´ ì¶”ê°€
            table.innerHTML = `<div style="color:#aaa; font-style:italic; margin-top:40px;">ğŸ§¹ ë°”ë‹¥ì´ ì²­ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.</div>`;
        }
    }
    
    function renderHand(cid, hand, active) {
        const cont = document.getElementById(cid); cont.innerHTML = '';
        hand.forEach((r, i) => {
            const c = document.createElement('div'); c.className = 'card'; c.innerText = (r===13?'J':r);
            c.onclick = () => { if(active) { c.classList.toggle('selected'); const si = selectedCards.findIndex(s=>s.idx===i); if(si>-1) selectedCards.splice(si,1); else selectedCards.push({rank:r, idx:i}); }};
            cont.appendChild(c);
        });
    }

function playCards() {
    if(!selectedCards.length) return;

    // 1. ì¡°ì»¤(13)ë¥¼ ì œì™¸í•œ ì¼ë°˜ ì¹´ë“œë“¤ë§Œ ì¶”ì¶œ
    const nonJokerCards = selectedCards.filter(c => c.rank !== 13);
    
    // ì¡°ì»¤ë§Œ ë‹¨ë…ìœ¼ë¡œ ë‚¼ ìˆ˜ ì—†ìŒ
    if (nonJokerCards.length === 0) {
        alert("ì¡°ì»¤ëŠ” ë‹¨ë…ìœ¼ë¡œ ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
        resetSelection(); // â˜… ì˜ëª» ì„ íƒí–ˆì„ ë•Œ ë¦¬ì…‹
        return;
    }

    // 2. ë³€ì‹ í•  ìˆ«ìì™€ ì „ì²´ ì¥ìˆ˜ ê³„ì‚°
    const effectiveRank = nonJokerCards[0].rank;
    const totalCount = selectedCards.length; 

    // 3. â˜… ë¬¸ì œì˜ êµ¬ê°„ â˜… : ì„œë¡œ ë‹¤ë¥¸ ìˆ«ìê°€ ì„ì—¬ìˆëŠ”ì§€ í™•ì¸
    if (!nonJokerCards.every(c => c.rank === effectiveRank)) {
        alert("ì„œë¡œ ë‹¤ë¥¸ ìˆ«ìì˜ ì¹´ë“œëŠ” í•¨ê»˜ ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! ì„ íƒì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.");
        resetSelection(); // â˜… 11, 11, 10 ì²˜ëŸ¼ ì˜ëª» ê³ ë¥´ë©´ ì‹¹ ë¹„ì›Œì¤Œ
        return;
    }

    // 4. ë°”ë‹¥ ì¹´ë“œì™€ ë¹„êµ
    if(lastPlayed.count > 0) {
        if(totalCount !== lastPlayed.count || effectiveRank >= lastPlayed.rank) {
            alert(`${lastPlayed.count}ì¥ìœ¼ë¡œ ${lastPlayed.rank}ë³´ë‹¤ ë‚®ì€ ìˆ«ìë¥¼ ë‚´ì•¼ í•©ë‹ˆë‹¤.`);
            resetSelection(); // â˜… ì¡°ê±´ ì•ˆ ë§ì„ ë•Œë„ ë¦¬ì…‹
            return;
        }
    }

    // 5. ì •ìƒì ì¸ ê²½ìš° ì„œë²„ ì „ì†¡
    const myIdx = players.findIndex(p => p.id === myID);
    if(isHost) {
        doPlay(effectiveRank, totalCount, myIdx);
    } else {
        conn.send({
            type: 'PLAY_REQ', 
            rank: effectiveRank, 
            count: totalCount, 
            pIdx: myIdx
        });
    }
}

// âœ¨ ì„ íƒì„ ê°•ì œë¡œ ë¹„ì›Œì£¼ëŠ” ë³´ì¡° í•¨ìˆ˜
function resetSelection() {
    selectedCards = []; // ë°ì´í„° ë¹„ìš°ê¸°
    const cards = document.querySelectorAll('.card');
    cards.forEach(c => c.classList.remove('selected')); // í™”ë©´ì—ì„œ ì£¼í™©ìƒ‰ í…Œë‘ë¦¬ ì œê±°
}

 function doPlay(rank, count, pIdx) {
    lastPlayed = {rank, count};

    // 1. ì„ íƒëœ ì¹´ë“œì˜ ì¸ë±ìŠ¤ë“¤ì„ ê°€ì ¸ì™€ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    const targetIndices = selectedCards.map(s => s.idx).sort((a, b) => b - a);
    
    // 2. ì‹¤ì œ ì†íŒ¨ì—ì„œ ì¹´ë“œ ì œê±°
    targetIndices.forEach(idx => {
        players[pIdx].hand.splice(idx, 1);
    });

    // âœ¨ [ì¶”ê°€ëœ í•µì‹¬ ì½”ë“œ] ì¹´ë“œë¥¼ ëƒˆìœ¼ë¯€ë¡œ ì„ íƒëœ ëª©ë¡ì„ ì¦‰ì‹œ ë¹„ì›ë‹ˆë‹¤.
    // ì´ ì½”ë“œê°€ ì—†ìœ¼ë©´ ë‹¤ìŒ í™”ë©´ì„ ê·¸ë¦´ ë•Œ ì´ì „ ì¡°ì»¤ ì •ë³´ê°€ ë‚¨ì•„ ë²„ê·¸ê°€ ìƒê¹ë‹ˆë‹¤.
    selectedCards = []; 
    
    // 3. íƒˆì¶œ ì²˜ë¦¬
    if(players[pIdx].hand.length === 0 && !players[pIdx].isFinished) {
        players[pIdx].isFinished = true;
        finishOrder.push(players[pIdx]);
        alert(`ğŸŠ ${players[pIdx].name}ë‹˜ ${finishOrder.length}ë“±ìœ¼ë¡œ íƒˆì¶œ! ğŸŠ`);
    }
    
    passCount = 0; 
    nextTurn();
}
    function passTurn() { if(isHost) doPass(); else conn.send({type:'PASS_REQ'}); }
 function doPass() { 
        // í˜„ì¬ ê²Œì„ ì¤‘ì¸(íƒˆì¶œ ì•ˆ í•œ) ì¸ì› í™•ì¸
        const activePlayers = players.filter(p => !p.isFinished).length;
        passCount++; 
        
        // [ìˆ˜ì •] ë‚˜ë¥¼ ì œì™¸í•œ ëª¨ë“  ì‚¬ëŒì´ íŒ¨ìŠ¤í•˜ë©´ ë°”ë‹¥ ì²­ì†Œ
        if(passCount >= activePlayers - 1) { 
            lastPlayed = { rank: 14, count: 0 };
            passCount = 0;
            // ë°”ë‹¥ ì²­ì†Œë¨ì„ ì•Œë¦¬ê¸° ìœ„í•´ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ ë° ë°©ì†¡
        }
        
        nextTurn(); 
    }

    function nextTurn() {
        const activePlayers = players.filter(p => !p.isFinished);
        
        if (activePlayers.length <= 1) {
            if (activePlayers.length === 1) {
                activePlayers[0].isFinished = true;
                finishOrder.push(activePlayers[0]);
            }

            // íƒˆì¶œ ìˆœì„œëŒ€ë¡œ í”Œë ˆì´ì–´ ì¬ë°°ì¹˜ ë° ì‹ ë¶„ ë¶€ì—¬
            players = [...finishOrder]; 
            players.forEach((p, i) => {
                if (i === 0) p.role = "ğŸ‘‘ ë‹¬ë¬´í‹°";
                else if (i === players.length - 1) p.role = "ğŸ’© ë†ë…¸";
                else p.role = `${i+1}ë“± í‰ë¯¼`;
            });

            const msg = { type: 'SHOW_RESULT', players: players };
            finishOrder = []; // ë‹¤ìŒ íŒì„ ìœ„í•´ ì´ˆê¸°í™”
            handleData(msg);
            broadcast(msg);
            return;
        }

        do { 
            currentPlayerIdx = (currentPlayerIdx + 1) % players.length; 
        } while(players[currentPlayerIdx].isFinished);

        const msg = {type:'GAME_START', players, turn:currentPlayerIdx, last:lastPlayed}; 
        handleData(msg); 
        broadcast(msg);
    }
    // ê²°ê³¼ í™”ë©´ì„ ì‹¤ì œë¡œ ê·¸ë ¤ì£¼ëŠ” í•¨ìˆ˜
    function showRoundResult() {
        showScreen('round-result-screen');
        const listDiv = document.getElementById('final-ranking-list');
        listDiv.innerHTML = players.map((p, i) => {
            let cls = (i === 0) ? 'badge-dalmuti' : (i === players.length - 1 ? 'badge-peon' : 'badge-common');
            return `
                <div class="role-item">
                    <span class="rank-badge ${cls}">${i + 1}ìœ„</span>: 
                    <b>${p.name}</b> <span style="font-size:0.8rem; color:#aaa;">(${p.role})</span>
                </div>
            `;
        }).join('');
    }

    // í™”ë©´ ì „í™˜ í•¨ìˆ˜ (ê¸°ì¡´ ì½”ë“œì— ì—†ì„ ê²½ìš° ëŒ€ë¹„)
    function showScreen(id) { 
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden')); 
        document.getElementById(id).classList.remove('hidden'); 
    }
</script>
</body>
</html>
