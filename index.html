<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë‹¬ë¬´í‹° ë©€í‹°í”Œë ˆì´</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --bg-color: #1a252f; --accent: #f1c40f; --dalmuti-color: #f1c40f; --peon-color: #95a5a6; }
        body { font-family: 'Malgun Gothic', sans-serif; background-color: var(--bg-color); color: white; margin: 0; padding: 10px; text-align: center; }
        
        /* ìƒíƒœë°” ìŠ¤íƒ€ì¼ */
        #status-bar { padding: 10px; margin-bottom: 10px; border-radius: 8px; font-size: 14px; background: #c0392b; font-weight: bold; transition: 0.3s; }
        .online { background: #27ae60 !important; }

        .screen { background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; max-width: 500px; margin: 10px auto; box-shadow: 0 4px 15px rgba(0,0,0,0.3); border: 1px solid #34495e; }
        
        #rank-board { background: rgba(255, 255, 255, 0.1); border-radius: 10px; padding: 10px; margin-bottom: 15px; border: 1px solid var(--accent); }
        .rank-badge { display: inline-block; padding: 5px 10px; margin: 2px; border-radius: 15px; font-size: 0.85rem; font-weight: bold; }
        .badge-dalmuti { background: var(--accent); color: #000; }
        .badge-peon { background: #7f8c8d; color: #fff; }
        .badge-common { background: #34495e; color: #fff; }

        .card-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-top: 15px; min-height: 110px; }
        .card { 
            width: 65px; height: 95px; background: white; border-radius: 8px; 
            border: 2px solid #333; cursor: pointer; position: relative;
            display: flex; align-items: center; justify-content: center; color: #2c3e50;
        }
        .card-number { font-size: 32px; font-weight: bold; }
        .card img { width: 100%; height: 100%; object-fit: cover; position: absolute; border-radius: 6px; }
        .card.selected { transform: translateY(-15px); border: 3px solid var(--accent); box-shadow: 0 0 15px var(--accent); z-index: 10; }
        
        button { padding: 12px 20px; border-radius: 8px; border: none; background: #e67e22; color: white; font-weight: bold; cursor: pointer; margin: 5px; font-size: 16px; width: 85%; }
        button:disabled { background: #7f8c8d; cursor: not-allowed; }
        .table-area { min-height: 120px; background: rgba(255,255,255,0.05); border-radius: 10px; margin: 15px 0; padding: 10px; border: 1px dashed #555; }
        .hidden { display: none !important; }
        
        input { padding: 12px; width: 80%; border-radius: 5px; border: 2px solid #34495e; font-size: 16px; margin-bottom: 10px; text-align: center; background: #ecf0f1; color: #2c3e50; }
        .role-item { margin: 10px 0; font-size: 1.1rem; padding: 10px; border-radius: 8px; background: rgba(255,255,255,0.1); }
    </style>
</head>
<body>

    <div id="status-bar">ì„œë²„ ì—°ê²° ì¤‘...</div>

    <div id="setup" class="screen">
        <h2 style="color:var(--accent)">ğŸ° ë‹¬ë¬´í‹° ì˜¨ë¼ì¸</h2>
        <input type="text" id="my-name" placeholder="ë‚´ ì´ë¦„ ì…ë ¥" autocomplete="off">
        <hr style="border: 0.5px solid #444; margin: 20px 0;">
        <button onclick="initPeer(true)">ìƒˆ ê²Œì„ ë°© ë§Œë“¤ê¸° (ë°©ì¥)</button>
        <div style="margin: 10px 0;">ë˜ëŠ”</div>
        <input type="text" id="join-id" placeholder="ë°© ì½”ë“œ(ID) ì…ë ¥">
        <button onclick="initPeer(false)" style="background:#2980b9;">ë°© ì°¸ì—¬í•˜ê¸°</button>
    </div>

    <div id="lobby" class="screen hidden">
        <h3>ğŸ“¢ ëŒ€ê¸°ì‹¤</h3>
        <p id="room-code-display" style="color:var(--accent); font-weight:bold;"></p>
        <div id="player-list-lobby" style="margin: 20px 0;"></div>
        <button id="start-game-btn" onclick="startRoleDrawing()" class="hidden">ëª¨ë‘ ëª¨ì„ (ì„œì—´ ì •í•˜ê¸°)</button>
    </div>

    <div id="role-draw" class="screen hidden">
        <h3>ğŸƒ ì²« ì„œì—´ ì •í•˜ê¸°</h3>
        <p id="role-msg">ì¹´ë“œë¥¼ í•œ ì¥ì”© ë½‘ìœ¼ì„¸ìš”!</p>
        <div id="role-cards" class="card-container"></div>
        <div id="role-results" style="margin-top:20px;"></div>
        <button id="tax-start-btn" class="hidden" onclick="prepareTaxPhase()">ì„¸ê¸ˆ ë‹¨ê³„ë¡œ</button>
    </div>

    <div id="game-board" class="screen hidden">
        <div id="rank-board"></div>
        <div id="turn-indicator" style="font-size:1.1rem; color:#3498db; font-weight:bold;">ëŒ€ê¸° ì¤‘...</div>
        <div class="table-area"><div id="last-played-cards" class="card-container"></div></div>
        
        <div id="my-hand-section">
            <div id="player-hand" class="card-container"></div>
            <div id="actions" style="margin-top:20px;">
                <button id="play-btn" onclick="playSelectedCards()">ì¹´ë“œ ë‚´ê¸°</button>
                <button onclick="passTurn()" style="background:#7f8c8d;">í†µê³¼ (Pass)</button>
            </div>
        </div>
    </div>

<script>
    const IMG_BASE = "https://raw.githubusercontent.com/hmkim199/java-dalmuti/master/src/dalmuti/img/";
    let peer = null, conn = null, connections = []; // connectionsëŠ” ë°©ì¥ ì „ìš©
    let isHost = false, myID = "", myName = "";
    
    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
    let players = [], currentPlayerIdx = 0, lastPlayed = { rank: 14, count: 0 }, selectedCards = [], passCount = 0;
    let rankDrawingDeck = [];

    // --- [1. ë„¤íŠ¸ì›Œí‚¹ ë¡œì§] ---

    function initPeer(hostFlag) {
        myName = document.getElementById('my-name').value.trim();
        if (!myName) return alert("ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
        
        isHost = hostFlag;
        peer = new Peer();

        peer.on('open', (id) => {
            myID = id;
            updateStatus(`ì—°ê²°ë¨! (ID: ${id})`, true);
            if (isHost) {
                showScreen('lobby');
                document.getElementById('room-code-display').innerText = `ë°© ì½”ë“œ: ${id}`;
                players.push({ id: myID, name: myName, hand: [], isFinished: false, roleTitle: "" });
                updateLobbyList();
                document.getElementById('start-game-btn').classList.remove('hidden');
            } else {
                const targetID = document.getElementById('join-id').value.trim();
                if (!targetID) return alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
                conn = peer.connect(targetID);
                setupConnection(conn);
            }
        });

        peer.on('connection', (connection) => {
            if (!isHost) return;
            setupConnection(connection);
        });

        peer.on('error', (err) => alert("PeerJS ì˜¤ë¥˜: " + err.type));
    }

    function setupConnection(c) {
        if (isHost) {
            connections.push(c);
            c.on('open', () => {
                c.send({ type: 'WELCOME' });
            });
        }

        c.on('data', (data) => {
            console.log("ë°›ì€ ë°ì´í„°:", data.type, data);
            handleData(data, c);
        });
    }

    function handleData(data, senderConn) {
        switch(data.type) {
            case 'WELCOME':
                senderConn.send({ type: 'JOIN', name: myName });
                showScreen('lobby');
                break;
            case 'JOIN':
                players.push({ id: senderConn.peer, name: data.name, hand: [], isFinished: false, roleTitle: "" });
                updateLobbyList();
                broadcast({ type: 'LOBBY_UPDATE', players });
                break;
            case 'LOBBY_UPDATE':
                players = data.players;
                updateLobbyList();
                break;
            case 'START_ROLE_DRAW':
                showScreen('role-draw');
                renderRoleBacks(data.count);
                break;
            case 'ROLE_CARD_OPEN':
                updateRoleCard(data.idx, data.rank, data.pName);
                break;
            case 'GAME_START':
                players = data.players;
                lastPlayed = data.lastPlayed;
                currentPlayerIdx = data.turn;
                showScreen('game-board');
                updateGameBoardUI();
                break;
            case 'ACTION_PLAY': // ë°©ì¥ì´ ì²˜ë¦¬
                processPlay(data.rank, data.count, data.pIdx);
                break;
            case 'ACTION_PASS': // ë°©ì¥ì´ ì²˜ë¦¬
                processPass();
                break;
        }
    }

    function broadcast(data) {
        connections.forEach(c => c.send(data));
    }

    // --- [2. ê²Œì„ UI ë° ë¡œì§] ---

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }

    function updateStatus(msg, online) {
        const bar = document.getElementById('status-bar');
        bar.innerText = msg;
        if (online) bar.classList.add('online');
    }

    function updateLobbyList() {
        const list = document.getElementById('player-list-lobby');
        list.innerHTML = players.map(p => `<div>ğŸ‘¤ ${p.name} ${p.id === myID ? '(ë‚˜)' : ''}</div>`).join('');
    }

    // [ì„œì—´ ì •í•˜ê¸°]
    function startRoleDrawing() {
        if (players.length < 2) return alert("ìµœì†Œ 2ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤.");
        rankDrawingDeck = Array.from({length: 12}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
        broadcast({ type: 'START_ROLE_DRAW', count: players.length });
        showScreen('role-draw');
        renderRoleBacks(players.length);
    }

    function renderRoleBacks(count) {
        const container = document.getElementById('role-cards');
        container.innerHTML = '';
        for(let i=0; i<count; i++) {
            container.innerHTML += `<div class="card" onclick="drawRoleCard(${i})"><div class="card-number">?</div></div>`;
        }
    }

    function drawRoleCard(idx) {
        if (!isHost) return; // ë°©ì¥ë§Œ ì¹´ë“œ ê²°ì • ê¶Œí•œ
        if (players.some(p => p.initialRank && p.roleIdx === idx)) return;
        
        const rank = rankDrawingDeck.pop();
        // ë°©ì¥ë¶€í„° ìˆœì„œëŒ€ë¡œ í• ë‹¹ (ë‹¨ìˆœí™”)
        const pIdx = players.findIndex(p => !p.initialRank);
        players[pIdx].initialRank = rank;
        
        const msg = { type: 'ROLE_CARD_OPEN', idx, rank, pName: players[pIdx].name };
        handleData(msg); // ë°©ì¥ ë³¸ì¸ ì—…ë°ì´íŠ¸
        broadcast(msg); // ë‹¤ë¥¸ ì‚¬ëŒ ì—…ë°ì´íŠ¸

        if (players.every(p => p.initialRank)) {
            setTimeout(finalizeRoles, 1500);
        }
    }

    function updateRoleCard(idx, rank, name) {
        const cards = document.getElementById('role-cards').children;
        cards[idx].innerHTML = `<div class="card-number">${rank}</div><img src="${IMG_BASE}${rank}.png" onerror="this.style.display='none'">`;
        cards[idx].style.pointerEvents = 'none';
        document.getElementById('role-results').innerHTML += `<div>${name}: ${rank}ë“±</div>`;
    }

    function finalizeRoles() {
        players.sort((a, b) => a.initialRank - b.initialRank);
        players.forEach((p, i) => {
            if (i === 0) p.roleTitle = "ğŸ‘‘ ë‹¬ë¬´í‹°";
            else if (i === players.length - 1) p.roleTitle = "ğŸ’© ë†ë…¸";
            else p.roleTitle = `${i+1}ë“± í‰ë¯¼`;
        });
        dealCards();
    }

    function dealCards() {
        let deck = [];
        for (let i = 1; i <= 12; i++) for (let j = 0; j < i; j++) deck.push(i);
        deck.push(13, 13);
        deck.sort(() => Math.random() - 0.5);
        
        players.forEach(p => p.hand = []);
        let i = 0; while (deck.length > 0) players[i++ % players.length].hand.push(deck.pop());
        players.forEach(p => p.hand.sort((a, b) => a - b));

        const startData = { type: 'GAME_START', players, lastPlayed: {rank:14, count:0}, turn: 0 };
        handleData(startData);
        broadcast(startData);
    }

    // [ë³¸ ê²Œì„ UI ì—…ë°ì´íŠ¸]
    function updateGameBoardUI() {
        const me = players.find(p => p.id === myID);
        const isMyTurn = players[currentPlayerIdx].id === myID;

        // ì‹ ë¶„ ë³´ë“œ
        const rb = document.getElementById('rank-board');
        rb.innerHTML = players.map((p, i) => `<span class="rank-badge ${i==0?'badge-dalmuti':(i==players.length-1?'badge-peon':'badge-common')}">${p.name}(${p.hand.length})</span>`).join(' ');

        document.getElementById('turn-indicator').innerText = isMyTurn ? "ğŸ”´ ë‚´ ì°¨ë¡€ì…ë‹ˆë‹¤!" : `âŒ› ${players[currentPlayerIdx].name}ì˜ ì°¨ë¡€...`;
        
        // ë‚´ ì†íŒ¨ ê·¸ë¦¬ê¸°
        const handDiv = document.getElementById('player-hand');
        handDiv.innerHTML = '';
        selectedCards = [];
        me.hand.forEach((rank, idx) => {
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `<div class="card-number">${rank==13?'J':rank}</div><img src="${IMG_BASE}${rank}.png" onerror="this.style.display='none'">`;
            card.onclick = () => {
                if(!isMyTurn) return;
                card.classList.toggle('selected');
                const fIdx = selectedCards.findIndex(c => c.idx === idx);
                if (fIdx > -1) selectedCards.splice(fIdx, 1); else selectedCards.push({ rank, idx });
            };
            handDiv.appendChild(card);
        });

        // ë°”ë‹¥ ì¹´ë“œ
        const table = document.getElementById('last-played-cards');
        table.innerHTML = '';
        if (lastPlayed.count > 0) {
            for(let i=0; i<lastPlayed.count; i++) {
                table.innerHTML += `<div class="card"><div class="card-number">${lastPlayed.rank==13?'J':lastPlayed.rank}</div><img src="${IMG_BASE}${lastPlayed.rank}.png" onerror="this.style.display='none'"></div>`;
            }
        } else {
            table.innerHTML = '<p style="color:#555">ë°”ë‹¥ì´ ë¹„ì—ˆìŠµë‹ˆë‹¤.</p>';
        }
    }

    function playSelectedCards() {
        if (selectedCards.length === 0) return;
        const rank = selectedCards[0].rank;
        if (!selectedCards.every(c => c.rank === rank || c.rank === 13)) return alert("ê°™ì€ ìˆ«ìë§Œ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤!");
        
        const myIdx = players.findIndex(p => p.id === myID);
        if (isHost) processPlay(rank, selectedCards.length, myIdx);
        else conn.send({ type: 'ACTION_PLAY', rank, count: selectedCards.length, pIdx: myIdx });
    }

    function passTurn() {
        if (isHost) processPass();
        else conn.send({ type: 'ACTION_PASS' });
    }

    // [ë°©ì¥ ì „ìš© ê²Œì„ í”„ë¡œì„¸ì„œ]
    function processPlay(rank, count, pIdx) {
        if (lastPlayed.count === 0 || (count === lastPlayed.count && rank < lastPlayed.rank)) {
            lastPlayed = { rank, count };
            // ì‹¤ì œ ì¹´ë“œ ì œê±° (ë’¤ì—ì„œë¶€í„° ì œê±°í•´ì•¼ ì¸ë±ìŠ¤ ì•ˆê¼¬ì„)
            const p = players[pIdx];
            // ì´ ì˜ˆì‹œì—ì„œëŠ” ì„ íƒëœ ì¸ë±ìŠ¤ ì •ë³´ê°€ í•„ìš”í•˜ë¯€ë¡œ ê°„ëµí™”í•˜ì—¬ ë­í¬ ê¸°ë°˜ìœ¼ë¡œ ì œê±°
            for(let i=0; i<count; i++) {
                const targetIdx = p.hand.indexOf(rank === 13 ? 13 : rank); // ì¡°ì»¤ ì²˜ë¦¬ ë“± í•„ìš”
                if (targetIdx > -1) p.hand.splice(targetIdx, 1);
            }
            
            passCount = 0;
            if (p.hand.length === 0) p.isFinished = true;
            
            nextTurn();
        } else {
            if(players[pIdx].id === myID) alert("ë‚¼ ìˆ˜ ì—†ëŠ” ì¹´ë“œì…ë‹ˆë‹¤.");
        }
    }

    function processPass() {
        passCount++;
        const activeCount = players.filter(p => !p.isFinished).length;
        if (passCount >= activeCount - 1) {
            lastPlayed = { rank: 14, count: 0 };
            passCount = 0;
        }
        nextTurn();
    }

    function nextTurn() {
        do { currentPlayerIdx = (currentPlayerIdx + 1) % players.length; } 
        while (players[currentPlayerIdx].isFinished);

        const state = { type: 'GAME_START', players, lastPlayed, turn: currentPlayerIdx };
        handleData(state);
        broadcast(state);
    }

</script>
</body>
</html>
