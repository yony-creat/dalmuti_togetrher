<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë‹¬ë¬´í‹° ì˜¨ë¼ì¸</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --bg-color: #1a252f; --accent: #f1c40f; --dalmuti-color: #f1c40f; --peon-color: #95a5a6; }
        body { font-family: 'Malgun Gothic', sans-serif; background-color: var(--bg-color); color: white; margin: 0; padding: 10px; text-align: center; }
        .screen { background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; max-width: 550px; margin: 10px auto; border: 1px solid #34495e; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        
        /* ì¹´ë“œ ë° ë ˆì´ì•„ì›ƒ */
        .card-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-top: 15px; min-height: 110px; }
        .card { width: 65px; height: 95px; background: white; border-radius: 8px; border: 2px solid #333; cursor: pointer; position: relative; display: flex; align-items: center; justify-content: center; color: #2c3e50; overflow: hidden; }
        .card-number { font-size: 28px; font-weight: bold; position: absolute; z-index: 1; }
        .card img { width: 100%; height: 100%; object-fit: cover; position: absolute; z-index: 2; }
        .card.selected { transform: translateY(-15px); border-color: var(--accent); box-shadow: 0 0 15px var(--accent); z-index: 10; }
        
        button { padding: 12px 20px; border-radius: 8px; border: none; background: #e67e22; color: white; font-weight: bold; cursor: pointer; margin: 5px; font-size: 16px; width: 85%; }
        .btn-small { width: auto; font-size: 11px; padding: 4px 8px; background: #34495e; border: 1px solid var(--accent); margin-left: 5px; }
        input { padding: 12px; width: 80%; border-radius: 5px; border: 2px solid #34495e; font-size: 16px; margin-bottom: 10px; text-align: center; background: #ecf0f1; color: #2c3e50; }
        
        .hidden { display: none; }
        #status-bar { padding: 10px; margin-bottom: 10px; border-radius: 8px; font-size: 14px; background: #c0392b; font-weight: bold; }
        .online { background: #27ae60 !important; }
        .player-badge { display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.1); padding: 8px; margin: 5px 0; border-radius: 10px; border: 1px solid #555; }
        .rank-item { margin: 10px 0; font-size: 1.1rem; padding: 10px; border-radius: 8px; background: rgba(255,255,255,0.1); }
    </style>
</head>
<body>
    <div id="status-bar">ğŸ“¡ ë¬´ì „ê¸° ì£¼íŒŒìˆ˜ ë§ì¶”ëŠ” ì¤‘...</div>

    <div id="setup-screen" class="screen">
        <div id="host-init">
            <button onclick="beHost()">ğŸ° ë‚´ê°€ ë°©ì¥ (ë°© ë§Œë“¤ê¸°)</button>
        </div>
        <div id="join-init" class="hidden">
            <input type="text" id="join-name" placeholder="ì‚¬ìš©í•  ì´ë¦„ ì…ë ¥">
            <button onclick="beGuest()">ì…ì¥í•˜ê¸°</button>
        </div>
    </div>

    <div id="lobby-screen" class="screen hidden">
        <div id="invite-box" class="hidden">
            <p style="font-size:12px; color:var(--accent);">ğŸ”— ì•„ë˜ ë§í¬ë¥¼ <b>íŒ€ì›ë“¤ì—ê²Œ</b> ê³µìœ í•˜ì„¸ìš”!</p>
            <div id="room-url" style="background:#000; padding:8px; font-size:10px; word-break:break-all; cursor:pointer;" onclick="copyLink()"></div>
        </div>
        <h3>ğŸ‘¥ ëŒ€ê¸°ì‹¤</h3>
        <div id="player-list"></div>
        <button id="draw-start-btn" class="hidden" onclick="hostStartRoleDraw()">ğŸƒ ì„œì—´ ì •í•˜ê¸° ì‹œì‘</button>
    </div>

    <div id="role-draw-screen" class="screen hidden">
        <h3>ğŸƒ ì„œì—´ ì •í•˜ê¸°</h3>
        <p>ì¹´ë“œë¥¼ í•œ ì¥ ê³¨ë¼ì£¼ì„¸ìš”! ìˆ«ìê°€ ì‘ì„ìˆ˜ë¡ ë†’ì€ ì‹ ë¶„ì´ ë©ë‹ˆë‹¤.</p>
        <div id="role-cards" class="card-container"></div>
        <div id="role-results" style="margin-top:20px; font-weight:bold;"></div>
        <button id="tax-start-btn" class="hidden" onclick="hostStartGamePhase()">ğŸ’° ê²Œì„ ì‹œì‘ (ì¹´ë“œ ë‚˜ëˆ„ê¸°)</button>
    </div>

    <div id="game-screen" class="screen hidden">
        <div id="rank-display" style="margin-bottom:15px; font-size: 0.8rem;"></div>
        <div id="turn-info" style="color:var(--accent); font-weight:bold; margin-bottom:10px; font-size:1.1rem;"></div>
        <div id="table" class="card-container" style="background:rgba(255,255,255,0.05); border-radius:10px; padding:10px;"></div>
        <div id="hand" class="card-container"></div>
        <div id="game-controls" class="hidden">
            <button onclick="playSelectedCards()">ì¹´ë“œ ë‚´ê¸°</button>
            <button onclick="passTurn()" style="background:#7f8c8d;">í†µê³¼ (Pass)</button>
        </div>
    </div>

    <div id="result-screen" class="screen hidden">
        <h3>ğŸ† ë¼ìš´ë“œ ê²°ê³¼</h3>
        <div id="final-ranking"></div>
        <div style="margin-top:20px;">
            <button id="continue-btn" class="hidden" onclick="hostStartGamePhase()" style="background:#2ecc71;">ì´ ê²°ê³¼ë¡œ ë‹¤ìŒ íŒ ì§„í–‰</button>
            <button onclick="location.reload()" style="background:#e74c3c;">ì²˜ìŒë¶€í„° ë‹¤ì‹œ í•˜ê¸° (ìƒˆë¡œê³ ì¹¨)</button>
        </div>
    </div>

<script>
    const IMG_BASE = "https://raw.githubusercontent.com/hmkim199/java-dalmuti/master/src/dalmuti/img/";
    let peer = new Peer({ config: { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] } });
    let connMap = {}, myRole, myHand = [], selected = [], myId, hostPeerId;
    let gameState = { players: [], status: 'lobby', turnIdx: 0, lastPlayed: {rank:14, count:0}, finishOrder: [] };
    const roomCode = new URLSearchParams(window.location.search).get('room');

    peer.on('open', (id) => {
        myId = id; document.getElementById('status-bar').innerText = "ğŸŸ¢ ì ‘ì† ì¤€ë¹„ ì™„ë£Œ";
        document.getElementById('status-bar').classList.add('online');
        if(roomCode) {
            hostPeerId = roomCode;
            document.getElementById('host-init').classList.add('hidden');
            document.getElementById('join-init').classList.remove('hidden');
        }
    });

    function beHost() {
        myRole = 'host'; hostPeerId = myId;
        const name = prompt("ì‚¬ìš©í•  ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”", "ë°©ì¥");
        gameState.players.push({id: myId, name, roleTitle: 'ì‹¬ì‚¬ì¤‘', rankVal: 0, isFinished: false});
        document.getElementById('room-url').innerText = window.location.href + "?room=" + myId;
        document.getElementById('invite-box').classList.remove('hidden');
        showScreen('lobby-screen'); updatePlayerList();
        peer.on('connection', (c) => {
            c.on('open', () => { c.on('data', (data) => handleData(data, c)); });
        });
    }

    function beGuest() {
        myRole = 'guest'; const name = document.getElementById('join-name').value;
        const conn = peer.connect(hostPeerId);
        conn.on('open', () => {
            conn.send({type: 'JOIN_REQ', name});
            showScreen('lobby-screen');
            conn.on('data', (data) => handleData(data, conn));
        });
        connMap[hostPeerId] = conn;
    }

    function delegateHost(targetId) {
        if(!confirm("í•´ë‹¹ íŒ€ì›ì—ê²Œ ë°©ì¥ ê¶Œí•œì„ ìœ„ì„í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
        const targetConn = connMap[targetId];
        if(targetConn) {
            targetConn.send({type: 'BECOME_HOST', state: gameState});
            myRole = 'guest'; hostPeerId = targetId;
            updatePlayerList();
        }
    }

    function handleData(data, conn) {
        if(data.type === 'JOIN_REQ') {
            connMap[conn.peer] = conn;
            gameState.players.push({id: conn.peer, name: data.name, roleTitle: 'ì‹¬ì‚¬ì¤‘', rankVal: 0, isFinished: false});
            broadcast({type: 'SYNC', state: gameState});
            updatePlayerList();
            document.getElementById('draw-start-btn').classList.remove('hidden');
        }
        if(data.type === 'BECOME_HOST') {
            myRole = 'host'; hostPeerId = myId;
            gameState = data.state;
            alert("ë°©ì¥ ê¶Œí•œì„ ìœ„ì„ë°›ì•˜ìŠµë‹ˆë‹¤.");
            updatePlayerList();
            if(gameState.status === 'lobby') document.getElementById('draw-start-btn').classList.remove('hidden');
        }
        if(data.type === 'SYNC') { 
            gameState = data.state; if(data.hand) myHand = data.hand;
            refreshUI(); 
        }
        if(data.type === 'PICK_RES') {
            const p = gameState.players.find(x => x.id === data.uid);
            p.rankVal = data.val; checkAllPicks();
        }
        if(data.type === 'FINISH_NOTI') {
            const p = gameState.players.find(x => x.id === data.uid);
            p.isFinished = true;
            if(!gameState.finishOrder.includes(data.uid)) gameState.finishOrder.push(data.uid);
            checkRoundEnd();
        }
    }

    function updatePlayerList() {
        const list = document.getElementById('player-list'); list.innerHTML = "";
        gameState.players.forEach(p => {
            const div = document.createElement('div'); div.className = 'player-badge';
            div.innerHTML = `ğŸ‘¤ ${p.name} ${p.id === hostPeerId ? '(ë°©ì¥)' : ''}`;
            if(myRole === 'host' && p.id !== myId) {
                div.innerHTML += `<button class="btn-small" onclick="delegateHost('${p.id}')">ìœ„ì„</button>`;
            }
            list.appendChild(div);
        });
    }

    function hostStartRoleDraw() {
        gameState.status = 'drawing';
        broadcast({type: 'SYNC', state: gameState});
        refreshUI();
    }

    function refreshUI() {
        if(gameState.status === 'drawing') {
            showScreen('role-draw-screen');
            const container = document.getElementById('role-cards'); container.innerHTML = "";
            for(let i=0; i<5; i++) container.innerHTML += `<div class="card" onclick="pickRoleCard(this)"><div class="card-number">?</div></div>`;
        }
        if(gameState.status === 'playing') { showScreen('game-screen'); renderGame(); }
        if(gameState.status === 'result') {
            showScreen('result-screen');
            document.getElementById('final-ranking').innerHTML = gameState.players.map((p, i) => `<div class="rank-item"><b>${i+1}ìœ„</b>: ${p.name} (${p.roleTitle})</div>`).join('');
            if(myRole === 'host') document.getElementById('continue-btn').classList.remove('hidden');
        }
    }

    function pickRoleCard(el) {
        if(el.classList.contains('selected')) return;
        const val = Math.floor(Math.random() * 12) + 1;
        el.innerHTML = `<div class="card-number">${val}</div><img src="${IMG_BASE}${val}.png" onerror="this.style.display='none'">`;
        el.classList.add('selected');
        if(myRole === 'host') { gameState.players.find(p => p.id === myId).rankVal = val; checkAllPicks(); }
        else { const c = connMap[hostPeerId]; if(c) c.send({type: 'PICK_RES', val, uid: myId}); }
    }

    function checkAllPicks() {
        if(gameState.players.every(p => p.rankVal > 0)) {
            gameState.players.sort((a,b) => a.rankVal - b.rankVal);
            assignRoles();
            document.getElementById('role-results').innerHTML = "ì„œì—´ í™•ì •! ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”.";
            document.getElementById('tax-start-btn').classList.remove('hidden');
            broadcast({type: 'SYNC', state: gameState});
        }
    }

    function assignRoles() {
        gameState.players.forEach((p, i) => {
            if(i === 0) p.roleTitle = "ğŸ‘‘ ìœ„ëŒ€í•œ ë‹¬ë¬´í‹°";
            else if(i === gameState.players.length - 1) p.roleTitle = "ğŸ’© ë†ë…¸";
            else p.roleTitle = (i+1) + "ë“± í‰ë¯¼";
            p.isFinished = false;
        });
    }

    function hostStartGamePhase() {
        let deck = []; for(let i=1; i<=12; i++) for(let j=0; j<i; j++) deck.push(i);
        deck.push(13, 13); deck.sort(() => Math.random() - 0.5);
        gameState.status = 'playing'; gameState.turnIdx = 0; gameState.finishOrder = [];
        gameState.lastPlayed = {rank:14, count:0};
        gameState.players.forEach((p, idx) => {
            let hand = []; for(let i=idx; i<deck.length; i+=gameState.players.length) hand.push(deck[i]);
            if(p.id === myId) myHand = hand;
            else { if(connMap[p.id]) connMap[p.id].send({type: 'SYNC', state: gameState, hand}); }
        });
        broadcast({type: 'SYNC', state: gameState});
        refreshUI();
    }

    function renderGame() {
        const p = gameState.players[gameState.turnIdx];
        document.getElementById('turn-info').innerText = p.id === myId ? "â­ ë‚´ ì°¨ë¡€!" : `ğŸ“¢ [${p.name}] ì°¨ë¡€`;
        document.getElementById('game-controls').classList.toggle('hidden', p.id !== myId);
        document.getElementById('rank-display').innerHTML = gameState.players.map(x => `<span>${x.roleTitle}:${x.name}</span>`).join(' | ');
        
        const table = document.getElementById('table'); table.innerHTML = "";
        for(let i=0; i<gameState.lastPlayed.count; i++) table.innerHTML += `<div class="card"><img src="${IMG_BASE}${gameState.lastPlayed.rank}.png"></div>`;
        
        const handDiv = document.getElementById('hand'); handDiv.innerHTML = "";
        myHand.sort((a,b)=>a-b).forEach((r, i) => {
            const c = document.createElement('div'); c.className = 'card';
            c.innerHTML = `<img src="${IMG_BASE}${r}.png">`;
            c.onclick = () => {
                c.classList.toggle('selected');
                const sIdx = selected.findIndex(s => s.i === i);
                if(sIdx > -1) selected.splice(sIdx, 1); else selected.push({r, i});
            };
            handDiv.appendChild(c);
        });
        selected = [];
    }

    function playSelectedCards() {
        if(selected.length === 0) return;
        const rank = selected[0].r;
        if(gameState.lastPlayed.count === 0 || (selected.length === gameState.lastPlayed.count && rank < gameState.lastPlayed.rank)) {
            gameState.lastPlayed = {rank, count: selected.length};
            selected.sort((a,b)=>b.i-a.i).forEach(s => myHand.splice(s.i, 1));
            if(myHand.length === 0) {
                if(myRole === 'host') {
                    gameState.players.find(x => x.id === myId).isFinished = true;
                    if(!gameState.finishOrder.includes(myId)) gameState.finishOrder.push(myId);
                    checkRoundEnd();
                } else { connMap[hostPeerId].send({type: 'FINISH_NOTI', uid: myId}); }
            }
            nextTurn();
        } else { alert("ë‚¼ ìˆ˜ ì—†ëŠ” ì¹´ë“œì…ë‹ˆë‹¤."); }
    }

    function nextTurn() {
        do { gameState.turnIdx = (gameState.turnIdx + 1) % gameState.players.length; } while(gameState.players[gameState.turnIdx].isFinished);
        if(myRole === 'host') broadcast({type: 'SYNC', state: gameState});
        else connMap[hostPeerId].send({type: 'SYNC_REQ', state: gameState});
        refreshUI();
    }

    function passTurn() { nextTurn(); }

    function checkRoundEnd() {
        if(gameState.players.filter(p => !p.isFinished).length <= 1) {
            let lastId = gameState.players.find(p => !p.isFinished)?.id;
            if(lastId && !gameState.finishOrder.includes(lastId)) gameState.finishOrder.push(lastId);
            let newPlayers = [];
            gameState.finishOrder.forEach(id => newPlayers.push(gameState.players.find(x => x.id === id)));
            gameState.players = newPlayers; assignRoles();
            gameState.status = 'result';
            broadcast({type: 'SYNC', state: gameState});
            refreshUI();
        }
    }

    function broadcast(data) { Object.values(connMap).forEach(c => c.send(data)); }
    function showScreen(id) {
        ['setup-screen', 'lobby-screen', 'role-draw-screen', 'game-screen', 'result-screen'].forEach(s => document.getElementById(s).classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }
    function copyLink() { navigator.clipboard.writeText(document.getElementById('room-url').innerText); alert("ë§í¬ ë³µì‚¬ ì™„ë£Œ!"); }
</script>
</body>
</html>
